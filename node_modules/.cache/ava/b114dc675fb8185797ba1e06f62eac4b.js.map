{"version":3,"sources":["binarySearchTree.js"],"names":["Node","constructor","data","left","right","BST","root","add","node","searchTree","findMin","current","findMax","has","remove","removeNode","tempNode","size","sizeHelper","bst","console","log","t","is"],"mappings":"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","file":"binarySearchTree.js","sourcesContent":["// two classes Node and BST\n// add method contains recursive function searchTree, which do all job\n// it compares node.data with left and right and on the last item when it is null, it adds new\n//\n\nclass Node {\n    constructor(data, left = null, right = null) {\n        this.data = data;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass BST {\n    constructor() {\n        this.root = null;\n    }\n\n    /*add(data){\n        const node = this.root;\n        if(node===null){\n            this.root = new Node(data)\n            return\n        }\n        const searchTree = (node)=>{\n            if(data < node.data){\n                if(node.left === null){\n                    node.left = new Node(data)\n                    return\n                }else{\n                    return searchTree(node.left)\n                }\n            }else if(data > node.data){\n                if(node.right===null){\n                    node.right = new Node(data)\n                    return\n                }else{\n                    return searchTree(node.right)\n                }\n            }else{\n                return\n            }\n\n        }\n        return searchTree(node)\n    }*/\n\n    add(data){\n        const node = this.root\n        if(node === null){\n            this.root = new Node(data)\n            return\n        }\n        const searchTree = (node)=>{\n            if(data < node.data){\n                if(node.left === null){\n                    node.left = new Node(data)\n                    return\n                }else{\n                    return searchTree(node.left)\n                }\n            }else if(data > node.data){\n                if(node.right ===null){\n                    node.right = new Node(data)\n                }else{\n                    return searchTree(node.right)\n                }\n            }else{\n                return null\n            }\n        }\n        return searchTree(node)\n    }\n\n    findMin() {\n        let current = this.root;\n        while (current.left !== null) {\n            current = current.left;\n        }\n        return current.data;\n    }\n\n    findMax() {\n        let current = this.root;\n        while (current.right !== null) {\n            current = current.right;\n        }\n        return current.data;\n    }\n\n    has(data) {\n        let current = this.root;\n        while (current) {\n            if (data === current.data) {\n                return true;\n            }\n            if (data < current.data) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n        return false;\n    }\n\n    /*remove(data) {\n        const removeNode = function(node, data) {\n            if (node == null) {\n                return null;\n            }\n            if (data == node.data) {\n                // node has no children\n                if (node.left == null && node.right == null) {\n                    return null;\n                }\n                // node has no left child\n                if (node.left == null) {\n                    return node.right;\n                }\n                // node has no right child\n                if (node.right == null) {\n                    return node.left;\n                }\n                // node has two children\n                var tempNode = node.right;\n                while (tempNode.left !== null) {\n                    tempNode = tempNode.left;\n                }\n                node.data = tempNode.data;\n                node.right = removeNode(node.right, tempNode.data);\n                return node;\n            } else if (data < node.data) {\n                node.left = removeNode(node.left, data);\n                return node;\n            } else {\n                node.right = removeNode(node.right, data);\n                return node;\n            }\n        }\n        this.root = removeNode(this.root, data);\n    }*/\n    remove(data){\n        const removeNode = (node, data) =>{\n            if(node === null){\n                return null\n            }\n            if(data === node.data){\n             if(node.left===null && node.right===null){\n                 return null\n             }\n             if(node.right === null){\n                 return node.left\n             }\n             if(node.left === null){\n                 return node.right\n             }\n\n             let tempNode = node.right;\n\n            while(tempNode.left){\n             tempNode = tempNode.left\n            }\n            node.data = tempNode.data;\n            node.right = removeNode(node.right, tempNode.data)\n            return node\n\n            }else if(data < node.data){\n                node.left = removeNode(node.left, data)\n                return node\n            }else if(data > node.data){\n                node.right = removeNode(node.right, data)\n                return node\n            }\n        }\n        this.root = removeNode(this.root, data)\n    }\n\n    /*sizeHelper(node) {\n        if (node) {\n            return 1 + this.sizeHelper(node.left) + this.sizeHelper(node.right);\n        }\n        return 0;\n    }\n\n    size () {\n        return this.sizeHelper(this.root);\n    }*/\n\n    size(){\n        const node = this.root\n        let sizeHelper = (node)=>{\n            if(node){\n                return 1 + sizeHelper(node.left) + sizeHelper(node.right)\n            }else{\n                return 0\n            }\n        }\n        return sizeHelper(node)\n    }\n}\n\nconst bst = new BST();\nbst.add(1)\nbst.add(2)\nbst.add(3)\nbst.add(4)\nbst.add(5)\nbst.add(6)\nbst.add(7)\nbst.add(8)\nbst.add(9)\nbst.add(10)\nbst.remove(5)\nconsole.log(bst.findMin())\nconsole.log(bst.findMax())\nconsole.log(bst.size())\n\nimport {test} from 'ava';\ntest(t => {\n    t.is(1, 1);\n})"]}