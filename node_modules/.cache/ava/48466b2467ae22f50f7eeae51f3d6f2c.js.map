{"version":3,"sources":["isBalanced.js"],"names":["isBalanced","str","stack","Stack","letter","push","pairOf","peek","pop","items","length","pairs","key","constructor","val","console","log"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyDA,SAASA,UAAT,CAAoBC,GAApB,EAAwB;AACpB,QAAIC,QAAQ,IAAIC,KAAJ,EAAZ;AACA,SAAI,IAAIC,MAAR,IAAkBH,GAAlB,EAAsB;AAClB,gBAAOG,MAAP;AACI,iBAAK,GAAL;AACA,iBAAK,GAAL;AACA,iBAAK,GAAL;AACIF,sBAAMG,IAAN,CAAWD,MAAX;AACA;AACJ,iBAAK,GAAL;AACA,iBAAK,GAAL;AACA,iBAAK,GAAL;AACI,oBAAGE,OAAOJ,MAAMK,IAAN,EAAP,MAAuBH,MAA1B,EAAiC;AAC7BF,0BAAMM,GAAN;AACH,iBAFD,MAEK;AACD,2BAAO,KAAP;AACH;AAbT;AAeH;AACD,WAAON,MAAMO,KAAN,CAAYC,MAAZ,KAAuB,CAA9B;AACH;;AAED,IAAIC,QAAQ;AACR,SAAI,GADI;AAER,SAAI,GAFI;AAGR,SAAI;AAHI,CAAZ;;AAMA,SAASL,MAAT,CAAgBM,GAAhB,EAAoB;AAChB,WAAOD,MAAMC,GAAN,CAAP;AACH;;AAED,MAAMT,KAAN,CAAW;AACPU,kBAAa;AACT,aAAKJ,KAAL,GAAa,EAAb;AACH;AACDJ,SAAKS,GAAL,EAAS;AACL,aAAKL,KAAL,CAAWJ,IAAX,CAAgBS,GAAhB;AACH;AACDN,UAAK;AACD,aAAKC,KAAL,CAAWD,GAAX;AACH;AACDD,WAAM;AACF,eAAO,KAAKE,KAAL,CAAW,KAAKA,KAAL,CAAWC,MAAX,GAAkB,CAA7B,CAAP;AACH;AAZM;;AAeXK,QAAQC,GAAR,CAAYhB,WAAW,2BAAX,CAAZ,E,CAAsD;AACtDe,QAAQC,GAAR,CAAYhB,WAAW,mBAAX,CAAZ,E,CAAsD;AACtDe,QAAQC,GAAR,CAAYhB,WAAW,sBAAX,CAAZ,E,CAAsD","file":"isBalanced.js","sourcesContent":["// balanced означает что сначала идут все открывающие потом все закрывающие\n// и поэтому можно удалять последний при сравнении закрывающего с парой того который записан\n// суть заключается в том, чтобы пройтись по буквам и если совпадают с открывающимися\n// записывать их в массив items объекта стэк, который инициализируется\n// внутри функции isBalanced\n// сначала кейсы для открывающих, break, потом для закрывающих\n// и в теле кейса совпадающего с закрывающим делаем проверку, если итерируемая буква является парой для peek (считывание последнего)\n// то делаем удаление pop\n\n/*\n\nfunction isBalanced(str){\n    let stack = new Stack();\n    for(let letter of str){\n        switch(letter){\n            case '(':\n            case '{':\n            case '[':\n                stack.push(letter);\n                break\n            case ')':\n            case '}':\n            case ']':\n                if(pairOf(stack.peek())===letter){\n                    stack.pop();\n                }else{\n                    return false;\n                }\n        }\n        return stack.size() === 0;\n    }\n}\n\nlet pairs = {\n    '{':'}',\n    '(':')',\n    '[':']'\n}\n\nfunction pairOf(key){\n    return pairOf(key);\n}\n\nclass Stack {\n    constructor(){\n        this.items = [];\n    }\n\n    push(item){\n        this.items.push(item);\n    }\n\n    pop(){\n        this.items.pop();\n    }\n\n    peek(){\n        this.items[this.items.length - 1];\n    }\n\n    size(){\n        return this.items.length;\n    }\n}\n*/\n\nfunction isBalanced(str){\n    let stack = new Stack();\n    for(let letter of str){\n        switch(letter){\n            case '{':\n            case '(':\n            case '[':\n                stack.push(letter)\n                break;\n            case '}':\n            case ')':\n            case ']':\n                if(pairOf(stack.peek())===letter){\n                    stack.pop()\n                }else{\n                    return false;\n                }\n        }\n    }\n    return stack.items.length === 0;\n}\n\nlet pairs = {\n    '{':'}',\n    '(':')',\n    '[':']'\n}\n\nfunction pairOf(key){\n    return pairs[key]\n}\n\nclass Stack{\n    constructor(){\n        this.items = []\n    }\n    push(val){\n        this.items.push(val)\n    }\n    pop(){\n        this.items.pop()\n    }\n    peek(){\n        return this.items[this.items.length-1]\n    }\n}\n\nconsole.log(isBalanced('(foo { bar (baz) [boo] })')); // true\nconsole.log(isBalanced('foo { bar { baz }'));         // false\nconsole.log(isBalanced('foo { (bar [baz] } )'));      // false\n"]}