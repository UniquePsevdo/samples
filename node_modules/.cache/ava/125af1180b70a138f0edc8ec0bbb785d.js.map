{"version":3,"sources":["hashMap.js"],"names":["HashMap","constructor","data","get","key","hash","slot","undefined","k","v","set","value","index","entryIdx","string","split","reduce","a","b","charCodeAt","t","map","is"],"mappings":";;AAiFA;;AAjFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA,MAAMA,OAAN,CAAa;AACTC,kBAAa;AACT,aAAKC,IAAL,GAAY,EAAZ;AACH;;AAEDC,QAAIC,GAAJ,EAAQ;AACJ,YAAIC,OAAOA,KAAKD,GAAL,CAAX;AACA,YAAIE,OAAO,KAAKJ,IAAL,CAAUG,IAAV,CAAX;AACA,YAAG,CAACC,IAAJ,EAAS;AACL,mBAAOC,SAAP;AACH;AACD,aAAI,IAAI,CAACC,CAAD,EAAIC,CAAJ,CAAR,IAAkBH,IAAlB,EAAuB;AACnB,gBAAGE,MAAMJ,GAAT,EAAa;AACT,uBAAOK,CAAP;AACH;AACJ;AACJ;;AAEDC,QAAIN,GAAJ,EAASO,KAAT,EAAe;AACX,YAAIC,QAAQP,KAAKD,GAAL,CAAZ;AACA,YAAIE,OAAO,KAAKJ,IAAL,CAAUU,KAAV,CAAX;AACA,YAAG,CAACN,IAAJ,EAAS;AACLA,mBAAO,EAAP;AACH;AACD,YAAIO,WAAW,CAAf;AACA,eAAMP,KAAKO,QAAL,CAAN,EAAqB;AACjB,gBAAGP,KAAKO,QAAL,EAAe,CAAf,MAAoBT,GAAvB,EAA2B;AACvB;AACH;AACDS;AACH;AACDP,aAAKO,QAAL,IAAiB,CAACT,GAAD,EAAMO,KAAN,CAAjB;AACH;AAhCQ;;AAmCb;AACA,SAASN,IAAT,CAAcS,MAAd,EAAsB;AAClB,WAAOA,OACFC,KADE,CACI,EADJ,EAEFC,MAFE,CAEK,CAACC,CAAD,EAAIC,CAAJ,KAAW,CAACD,KAAK,CAAN,IAAWA,CAAZ,GAAiBC,EAAEC,UAAF,CAAa,CAAb,CAFhC,EAEiD,IAFjD,CAAP;AAGH;;AAED;;AAIA,eAAK,SAAL,EAAgBC,KAAK;AACjB,QAAIC,MAAM,IAAIrB,OAAJ,EAAV;AACAqB,QAAIX,GAAJ,CAAQ,KAAR,EAAe,GAAf;AACAW,QAAIX,GAAJ,CAAQ,KAAR,EAAe,KAAf;AACAW,QAAIX,GAAJ,CAAQ,KAAR,EAAe,KAAf;AACAU,MAAEE,EAAF,CAAKD,IAAIlB,GAAJ,CAAQ,KAAR,CAAL,EAAqB,GAArB;AACAiB,MAAEE,EAAF,CAAKD,IAAIlB,GAAJ,CAAQ,KAAR,CAAL,EAAqB,KAArB;AACAiB,MAAEE,EAAF,CAAKD,IAAIlB,GAAJ,CAAQ,KAAR,CAAL,EAAqBI,SAArB;AACH,CARD","file":"hashMap.js","sourcesContent":["/*class HashMap {\n    constructor() {\n        this.data = []\n    }\n    get(key) {\n        let index = hash(key)\n        let slot = this.data[index]\n        if (!slot) {\n            return undefined\n        }\n        for (let [k, v] of slot) {\n            if (key === k) {\n                return v\n            }\n        }\n    }\n    set(key, value) {\n        let index = hash(key)\n        if (!this.data[index]) {\n            this.data[index] = []\n        }\n        let slot = this.data[index]\n        let indexInSlot = 0\n\n\n        while (slot[indexInSlot]) {\n            if (slot[indexInSlot][0] === key) {\n                break\n            }\n            indexInSlot++\n        }\n\n        // переопределяем массив-пару ключ значение\n        slot[indexInSlot] = [key, value]\n    }\n}*/\n\nclass HashMap{\n    constructor(){\n        this.data = []\n    }\n\n    get(key){\n        let hash = hash(key)\n        let slot = this.data[hash]\n        if(!slot){\n            return undefined\n        }\n        for(let [k, v] of slot){\n            if(k === key){\n                return v\n            }\n        }\n    }\n\n    set(key, value){\n        let index = hash(key)\n        let slot = this.data[index]\n        if(!slot){\n            slot = []\n        }\n        let entryIdx = 0;\n        while(slot[entryIdx]){\n            if(slot[entryIdx][0]===key){\n                break\n            }\n            entryIdx++\n        }\n        slot[entryIdx] = [key, value]\n    }\n}\n\n// hash function (provided)\nfunction hash(string) {\n    return string\n        .split('')\n        .reduce((a, b) => ((a << 5) + a) + b.charCodeAt(0), 5381)\n}\n\n/// tests\n\nimport { test } from 'ava'\n\ntest('HashMap', t => {\n    let map = new HashMap\n    map.set('abc', 123)\n    map.set('foo', 'bar')\n    map.set('foo', 'baz')\n    t.is(map.get('abc'), 123)\n    t.is(map.get('foo'), 'baz')\n    t.is(map.get('def'), undefined)\n})\n"]}