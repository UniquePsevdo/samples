'use strict';

// balanced означает что сначала идут все открывающие потом все закрывающие
// и поэтому можно удалять последний при сравнении закрывающего с парой того который записан
// суть заключается в том, чтобы пройтись по буквам и если совпадают с открывающимися
// записывать их в массив items объекта стэк, который инициализируется
// внутри функции isBalanced
// сначала кейсы для открывающих, break, потом для закрывающих
// и в теле кейса совпадающего с закрывающим делаем проверку, если итерируемая буква является парой для peek (считывание последнего)
// то делаем удаление pop

/*

function isBalanced(str){
    let stack = new Stack();
    for(let letter of str){
        switch(letter){
            case '(':
            case '{':
            case '[':
                stack.push(letter);
                break
            case ')':
            case '}':
            case ']':
                if(pairOf(stack.peek())===letter){
                    stack.pop();
                }else{
                    return false;
                }
        }
        return stack.size() === 0;
    }
}

let pairs = {
    '{':'}',
    '(':')',
    '[':']'
}

function pairOf(key){
    return pairOf(key);
}

class Stack {
    constructor(){
        this.items = [];
    }

    push(item){
        this.items.push(item);
    }

    pop(){
        this.items.pop();
    }

    peek(){
        this.items[this.items.length - 1];
    }

    size(){
        return this.items.length;
    }
}
*/

function isBalanced(str) {
    let stack = new Stack();
    for (let letter of str) {
        switch (letter) {
            case '{':
            case '(':
            case '[':
                stack.push(letter);
                break;
            case '}':
            case ')':
            case ']':
                if (pairOf(stack.peek()) === letter) {
                    stack.pop();
                } else {
                    return false;
                }
        }
    }
    return stack.items.length === 0;
}

let pairs = {
    '{': '}',
    '(': ')',
    '[': ']'
};

function pairOf(key) {
    return pairs[key];
}

class Stack {
    constructor() {
        this.items = [];
    }
    push(val) {
        this.items.push(val);
    }
    pop() {
        this.items.pop();
    }
    peek() {
        return this.items[this.items.length - 1];
    }
}

console.log(isBalanced('(foo { bar (baz) [boo] })')); // true
console.log(isBalanced('foo { bar { baz }')); // false
console.log(isBalanced('foo { (bar [baz] } )')); // false
//# sourceMappingURL=/Users/mac/WebstormProjects/interview/node_modules/.cache/ava/48466b2467ae22f50f7eeae51f3d6f2c.js.map